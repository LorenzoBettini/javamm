/*
 * generated by Xtext
 */
package javamm.validation

import com.google.inject.Inject
import java.util.ArrayList
import javamm.javamm.JavammBranchingStatement
import javamm.javamm.JavammBreakStatement
import javamm.javamm.JavammContinueStatement
import javamm.javamm.JavammMethod
import javamm.javamm.JavammPackage
import javamm.javamm.Main
import javamm.util.JavammNodeModelUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.common.types.JvmFormalParameter
import org.eclipse.xtext.util.Wrapper
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XAbstractFeatureCall
import org.eclipse.xtext.xbase.XAbstractWhileExpression
import org.eclipse.xtext.xbase.XAssignment
import org.eclipse.xtext.xbase.XBasicForLoopExpression
import org.eclipse.xtext.xbase.XDoWhileExpression
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.XReturnExpression
import org.eclipse.xtext.xbase.XSwitchExpression
import org.eclipse.xtext.xbase.XVariableDeclaration
import org.eclipse.xtext.xbase.XbasePackage
import org.eclipse.xtext.xbase.validation.IssueCodes
import org.eclipse.xtext.xbase.validation.XbaseValidator

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class JavammValidator extends XbaseValidator {
	
	public static val PREFIX = "javamm."
	
	public static val NOT_ARRAY_TYPE = PREFIX + "NotArrayType"
	
	public static val INVALID_BRANCHING_STATEMENT = PREFIX + "InvalidBranchingStatement"

	public static val MISSING_SEMICOLON = PREFIX + "MissingSemicolon"
	
	static val xbasePackage = XbasePackage.eINSTANCE;
	
	val semicolonStatements = #{
		JavammBranchingStatement,
		XVariableDeclaration,
		XDoWhileExpression,
		XReturnExpression,
		XAssignment,
		XAbstractFeatureCall
	}

	val featuresForRequiredSemicolon = #{
		xbasePackage.XBlockExpression_Expressions,
		xbasePackage.XIfExpression_Then,
		xbasePackage.XIfExpression_Else,
		xbasePackage.XCasePart_Then,
		xbasePackage.XAbstractWhileExpression_Body
	}

	@Inject extension JavammNodeModelUtil
	
	override protected getEPackages() {
		val result = new ArrayList<EPackage>(super.getEPackages());
	    result.add(JavammPackage.eINSTANCE);
	    result.add(EPackage.Registry.INSTANCE.getEPackage("http://www.eclipse.org/xtext/xbase/Xbase"));
	    result.add(EPackage.Registry.INSTANCE.getEPackage("http://www.eclipse.org/xtext/common/JavaVMTypes"));
	    result.add(EPackage.Registry.INSTANCE.getEPackage("http://www.eclipse.org/xtext/xbase/Xtype"));
		return result;
	}

	override protected checkAssignment(XExpression expression, EStructuralFeature feature, boolean simpleAssignment) {
		if (expression instanceof XAbstractFeatureCall) {
			val assignmentFeature = expression.feature
			if (assignmentFeature instanceof JvmFormalParameter) {
				// all parameters are considered NOT final
				return;
			}
		}
		
		super.checkAssignment(expression, feature, simpleAssignment)
	}
	
	@Check
	def void checkContinue(JavammContinueStatement st) {
		checkBranchingStatementInternal(st, "a loop",
			XAbstractWhileExpression, XBasicForLoopExpression
		)
	}

	@Check
	def void checkBreak(JavammBreakStatement st) {
		checkBranchingStatementInternal(st, "a loop or a switch",
			XAbstractWhileExpression, XBasicForLoopExpression,
			XSwitchExpression
		)
	}

	@Check
	def void checkSwitch(XSwitchExpression sw) {
		val switchExpressionType = getActualType(sw.^switch)
		for (c : sw.cases) {
			val caseType = getActualType(c.^case)
			if (!switchExpressionType.isAssignableFrom(caseType)) {
				error(
					String.format("Type mismatch: cannot convert from %s to %s",
						caseType.humanReadableName, switchExpressionType.humanReadableName
					),
					c,
					XbasePackage.eINSTANCE.XCasePart_Case,
					IssueCodes.INCOMPATIBLE_TYPES	
				)
			}
		}
	}

	def private checkBranchingStatementInternal(JavammBranchingStatement st, String errorDetails, Class<? extends EObject>... validContainers) {
		val container = Wrapper.wrap(st.eContainer)
		while (!((container.get instanceof JavammMethod) || (container.get instanceof Main))) {
			if (validContainers.exists[c | c.isInstance(container.get)]) {
				return;
			}
			container.set(container.get.eContainer)
		}
		error(
			st.instruction + " cannot be used outside of " + errorDetails,
			st, null, INVALID_BRANCHING_STATEMENT
		)
	}

	@Check
	def checkMissingSemicolon(XExpression e) {
		if (e.hasToBeCheckedForMissingSemicolon && !e.hasSemicolon) {
			error(
				'Syntax error, insert ";" to complete Statement',
				e, null, MISSING_SEMICOLON
			)
		}
	}

	def private hasToBeCheckedForMissingSemicolon(XExpression e) {
		val expClass = e.class
		val containingFeature = e.eContainingFeature
		semicolonStatements.exists[c | 
			c.isAssignableFrom(expClass) &&
			featuresForRequiredSemicolon.exists[f | f == containingFeature]
		]		
	}

}
