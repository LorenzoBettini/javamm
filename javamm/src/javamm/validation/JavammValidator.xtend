/*
 * generated by Xtext
 */
package javamm.validation

import java.util.ArrayList
import javamm.javamm.JavammBranchingStatement
import javamm.javamm.JavammBreakStatement
import javamm.javamm.JavammContinueStatement
import javamm.javamm.JavammMethod
import javamm.javamm.JavammPackage
import javamm.javamm.Main
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.common.types.JvmFormalParameter
import org.eclipse.xtext.util.Wrapper
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XAbstractFeatureCall
import org.eclipse.xtext.xbase.XAbstractWhileExpression
import org.eclipse.xtext.xbase.XBasicForLoopExpression
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.validation.XbaseValidator
import org.eclipse.xtext.xbase.XSwitchExpression

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class JavammValidator extends XbaseValidator {
	
	public static val PREFIX = "javamm."
	
	public static val NOT_ARRAY_TYPE = PREFIX + "NotArrayType"
	
	public static val INVALID_BRANCHING_STATEMENT = PREFIX + "InvalidBranchingStatement"
	
	override protected getEPackages() {
		val result = new ArrayList<EPackage>(super.getEPackages());
	    result.add(JavammPackage.eINSTANCE);
	    result.add(EPackage.Registry.INSTANCE.getEPackage("http://www.eclipse.org/xtext/xbase/Xbase"));
	    result.add(EPackage.Registry.INSTANCE.getEPackage("http://www.eclipse.org/xtext/common/JavaVMTypes"));
	    result.add(EPackage.Registry.INSTANCE.getEPackage("http://www.eclipse.org/xtext/xbase/Xtype"));
		return result;
	}

	override protected checkAssignment(XExpression expression, EStructuralFeature feature, boolean simpleAssignment) {
		if (expression instanceof XAbstractFeatureCall) {
			val assignmentFeature = expression.feature
			if (assignmentFeature instanceof JvmFormalParameter) {
				// all parameters are considered NOT final
				return;
			}
		}
		
		super.checkAssignment(expression, feature, simpleAssignment)
	}
	
	@Check
	def void checkContinue(JavammContinueStatement st) {
		checkBranchingStatementInternal(st, "a loop",
			XAbstractWhileExpression, XBasicForLoopExpression
		)
	}

	@Check
	def void checkBreak(JavammBreakStatement st) {
		checkBranchingStatementInternal(st, "a loop or a switch",
			XAbstractWhileExpression, XBasicForLoopExpression,
			XSwitchExpression
		)
	}

	def private checkBranchingStatementInternal(JavammBranchingStatement st, String errorDetails, Class<? extends EObject>... validContainers) {
		val container = Wrapper.wrap(st.eContainer)
		while (!((container.get instanceof JavammMethod) || (container.get instanceof Main))) {
			if (validContainers.exists[c | c.isInstance(container.get)]) {
				return;
			}
			container.set(container.get.eContainer)
		}
		error(
			st.instruction + " cannot be used outside of " + errorDetails,
			st, null, INVALID_BRANCHING_STATEMENT
		)
	}
}
