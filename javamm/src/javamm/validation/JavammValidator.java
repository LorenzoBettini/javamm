/**
 * generated by Xtext
 */
package javamm.validation;

import static org.eclipse.xtext.xbase.typesystem.util.Multimaps2.newLinkedHashListMultimap;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;
import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;

import com.google.common.collect.ListMultimap;
import com.google.inject.Inject;

import javamm.javamm.JavammMethod;
import javamm.javamm.JavammPackage;
import javamm.javamm.JavammProgram;
import javamm.javamm.Main;
import javamm.util.JavammModelUtil;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class JavammValidator extends AbstractJavammValidator {
	public static final String PREFIX = "javamm.";

	public static final String DUPLICATE_METHOD = (JavammValidator.PREFIX + "DuplicateMethod");

	@Inject
	private JavammModelUtil javammModelUtil;

	@Inject
	private OverrideHelper overrideHelper;

	@Check
	public void checkDuplicateMethods(final JavammProgram p) {
		final JvmGenericType javaClass = javammModelUtil.getInferredJavaClass(p);
		final List<IResolvedOperation> methods = overrideHelper.getResolvedFeatures(javaClass)
				.getDeclaredOperations();
		final ListMultimap<String, JvmOperation> map = duplicatesMultimap();
		for (final IResolvedOperation d : methods) {
			map.put(d.getResolvedErasureSignature(), d.getDeclaration());
		}
		for (final Map.Entry<String, Collection<JvmOperation>> entry : map.asMap().entrySet()) {
			final Collection<JvmOperation> duplicates = entry.getValue();
			if (duplicates.size() > 1) {
				Map<Boolean, List<JvmOperation>> groups = duplicates.stream()
					.collect(Collectors
						.groupingBy(it -> javammModelUtil.getOriginalSource(it) instanceof Main));
				boolean mainHasBeenGenerated = groups.get(true) != null;
				if (mainHasBeenGenerated) {
					List<JvmOperation> methodsWithNameMain = groups.get(false);
					for (JvmOperation m : methodsWithNameMain) {
						error(entry.getKey() + " is a reserved method",
							javammModelUtil.getOriginalSource(m),
							JavammPackage.eINSTANCE.getJavammMethod_Name(),
							JavammValidator.DUPLICATE_METHOD);
					}
				} else {
					for (final JvmOperation d : duplicates) {
						error("Duplicate definition \'" + d.getSimpleName() + "\'",
							javammModelUtil.getOriginalSource(d),
							JavammPackage.eINSTANCE.getJavammMethod_Name(),
							JavammValidator.DUPLICATE_METHOD);
					}
				}
			}
		}
	}

	@Check
	public void checkMain(final Main m) {
		checkVariableInitialization(m);
	}

	@Check
	public void checkMethod(final JavammMethod method) {
		final XBlockExpression body = ((XBlockExpression) method.getBody());
		checkVariableInitialization(body);
		checkMissingReturn(body);
	}

	private <K extends Object, T extends Object> ListMultimap<K, T> duplicatesMultimap() {
		return newLinkedHashListMultimap();
	}
}
