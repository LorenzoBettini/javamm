/**
 * generated by Xtext
 */
package javamm.validation;

import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.mapping;
import static java.util.stream.Collectors.toList;

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;
import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;

import com.google.inject.Inject;

import javamm.javamm.JavammMethod;
import javamm.javamm.JavammPackage;
import javamm.javamm.JavammProgram;
import javamm.javamm.Main;
import javamm.util.JavammModelUtil;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class JavammValidator extends AbstractJavammValidator {
	public static final String PREFIX = "javamm.";

	public static final String DUPLICATE_METHOD = (JavammValidator.PREFIX + "DuplicateMethod");

	@Inject
	private JavammModelUtil javammModelUtil;

	@Inject
	private OverrideHelper overrideHelper;

	@Check
	public void checkDuplicateMethods(final JavammProgram p) {
		JvmGenericType javaClass = javammModelUtil.getInferredJavaClass(p);
		List<IResolvedOperation> methods = overrideHelper.getResolvedFeatures(javaClass)
				.getDeclaredOperations();
		Map<String, List<JvmOperation>> operationsByEraseSignature = methods.stream()
			.collect(groupingBy(IResolvedOperation::getResolvedErasureSignature,
				mapping(IResolvedOperation::getDeclaration, toList())));
		operationsByEraseSignature.entrySet().stream()
			.filter(entry -> entry.getValue().size() > 1)
			.forEach(this::reportErrorForDuplicates);
	}

	private void reportErrorForDuplicates(final Entry<String, List<JvmOperation>> entry) {
		List<JvmOperation> duplicates = entry.getValue();
		Map<Boolean, List<JvmOperation>> groups = duplicates.stream()
			.collect(groupingBy(it -> javammModelUtil.getOriginalSource(it) instanceof Main));
		boolean mainHasBeenGenerated = groups.get(true) != null;
		if (mainHasBeenGenerated) {
			List<JvmOperation> methodsWithNameMain = groups.get(false);
			for (JvmOperation m : methodsWithNameMain) {
				error(entry.getKey() + " is a reserved method",
					javammModelUtil.getOriginalSource(m),
					JavammPackage.eINSTANCE.getJavammMethod_Name(),
					JavammValidator.DUPLICATE_METHOD);
			}
		} else {
			for (JvmOperation d : duplicates) {
				error("Duplicate definition \'" + d.getSimpleName() + "\'",
					javammModelUtil.getOriginalSource(d),
					JavammPackage.eINSTANCE.getJavammMethod_Name(),
					JavammValidator.DUPLICATE_METHOD);
			}
		}
	}

	@Check
	public void checkMain(final Main m) {
		checkVariableInitialization(m);
	}

	@Check
	public void checkMethod(final JavammMethod method) {
		final XBlockExpression body = ((XBlockExpression) method.getBody());
		checkVariableInitialization(body);
		checkMissingReturn(body);
	}
}
